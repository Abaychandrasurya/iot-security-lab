# ESP32_IoT_Security_10_Firmwares_Project

This repository contains a single PlatformIO project that builds 10 firmware variants (FW1..FW10) for the ESP32 IoT security classroom. Each firmware is created by a PlatformIO environment using build flags that enable/disable vulnerability behaviors. The ESP32 hosts a small web UI for Wiâ€‘Fi/MQTT/Blynk provisioning and a live "Serial Monitor" web page (WebSocket) that shows device logs in the browser.

---

=== platformio.ini ===
[platformio]
default_env = fw1

[env:fw1]
platform = espressif32
board = esp32dev
framework = arduino
build_flags = -DFW1 -DWIFI_OPEN -DCLOUD_HTTP -DTOKEN_HARDCODED
lib_deps = mikalhart/RF24@^1.4.3, bblanchon/ArduinoJson@^6.18.5, blynkkk/Blynk@^0.6.1, knolleary/PubSubClient@^2.8, me-no-dev/AsyncTCP@^1.1.3, me-no-dev/ESPAsyncWebServer@^1.2.3, ottofly/SdFat@^1.0

[env:fw2]
platform = espressif32
board = esp32dev
framework = arduino
build_flags = -DFW2 -DRADIO_PLAINTEXT -DNO_SEQNUM -DSD_PLAINTEXT
lib_deps = mikalhart/RF24@^1.4.3, bblanchon/ArduinoJson@^6.18.5, knolleary/PubSubClient@^2.8, me-no-dev/AsyncTCP@^1.1.3, me-no-dev/ESPAsyncWebServer@^1.2.3, ottofly/SdFat@^1.0

[env:fw3]
platform = espressif32
board = esp32dev
framework = arduino
build_flags = -DFW3 -DOTA_HTTP -DOTA_NO_SIG -DWIFI_OPEN
lib_deps = ...

[env:fw4]
platform = espressif32
board = esp32dev
framework = arduino
build_flags = -DFW4 -DCLOUD_MQTT -DMQTT_ANON -DTOKEN_PLAINTEXT
lib_deps = ...

[env:fw5]
platform = espressif32
board = esp32dev
framework = arduino
build_flags = -DFW5 -DHARDCODED_CREDS
lib_deps = ...

[env:fw6]
platform = espressif32
board = esp32dev
framework = arduino
build_flags = -DFW6 -DWEAK_CRYPTO
lib_deps = ...

[env:fw7]
platform = espressif32
board = esp32dev
framework = arduino
build_flags = -DFW7 -DOTA_HTTP -DOTA_NO_SIG -DALLOW_UPLOAD
lib_deps = ...

[env:fw8]
platform = espressif32
board = esp32dev
framework = arduino
build_flags = -DFW8 -DDEBUG_VERBOSE -DPRINT_LOGS
lib_deps = ...

[env:fw9]
platform = espressif32
board = esp32dev
framework = arduino
build_flags = -DFW9 -DDOS_VULN
lib_deps = ...

[env:fw10]
platform = espressif32
board = esp32dev
framework = arduino
build_flags = -DFW10 -DALL_INSECURE
lib_deps = ...


---

=== src/main.cpp ===
```cpp
/*
  ESP32 IoT Security Classroom - Unified firmware
  - Supports compile-time flags to enable vulnerability behaviours
  - Features: WiFi provisioning portal, SD config, NRF24 comms, MQTT, Blynk, OTA, Web Serial (WebSocket)
  - Hardware assumed:
    DHT not used here; using LDR on ADC
    nRF24L01 on SPI
    SD on SPI CS pin
*/

#include <Arduino.h>
#include <WiFi.h>
#include <AsyncTCP.h>
#include <ESPAsyncWebServer.h>
#include <SPI.h>
#include <SD.h>
#include <FS.h>
#include <PubSubClient.h>
#include <ArduinoJson.h>
#include <WebSocketsServer.h>
#include <RF24.h>

// Optional Blynk
#ifdef BLYNK
  #include <BlynkSimpleEsp32.h>
#endif

// Hardware pins (example)
#define LDR_PIN 34 // ADC1_CH6
#define LED_PIN 2
#define BUZZER_PIN 14
#define BUTTON_PIN 15
#define SD_CS 13

// nRF24 pins
#define RF_CE 5
#define RF_CSN 15
RF24 radio(RF_CE, RF_CSN);

// Global objects
AsyncWebServer server(80);
WebSocketsServer webSocket = WebSocketsServer(81);
WiFiClient espClient;
PubSubClient mqttClient(espClient);

String deviceId;
String modeName;

// Simple logger buffer and web socket broadcast
String logBuffer;

void logEvent(const String &s){
  String line = String(millis()) + ": " + s;
  Serial.println(line);
  // keep small buffer
  logBuffer = line;
  // broadcast to websocket clients
  webSocket.broadcastTXT(line);
}

// SD config struct
struct Config {
  String ssid;
  String pass;
  String mqtt_server;
  int mqtt_port;
  String mqtt_user;
  String mqtt_pass;
  String blynk_token;
  String device_id;
  String mode;
} cfg;

bool loadConfig(){
  if(!SD.begin(SD_CS)){
    logEvent("SD init failed");
    return false;
  }
  if(!SD.exists("config.json")){
    logEvent("config.json not found on SD");
    return false;
  }
  File f = SD.open("config.json");
  if(!f){ logEvent("failed to open config.json"); return false; }
  String js;
  while(f.available()) js += char(f.read());
  f.close();
  DynamicJsonDocument doc(1024);
  DeserializationError err = deserializeJson(doc, js);
  if(err){ logEvent("config parse error"); return false; }
  cfg.ssid = doc["ssid"].as<String>();
  cfg.pass = doc["pass"].as<String>();
  cfg.mqtt_server = doc["mqtt_server"].as<String>();
  cfg.mqtt_port = doc["mqtt_port"] | 1883;
  cfg.mqtt_user = doc["mqtt_user"].as<String>();
  cfg.mqtt_pass = doc["mqtt_pass"].as<String>();
  cfg.blynk_token = doc["blynk_token"].as<String>();
  cfg.device_id = doc["device_id"].as<String>();
  cfg.mode = doc["mode"].as<String>();
  return true;
}

void saveConfig(){
  DynamicJsonDocument doc(1024);
  doc["ssid"] = cfg.ssid;
  doc["pass"] = cfg.pass;
  doc["mqtt_server"] = cfg.mqtt_server;
  doc["mqtt_port"] = cfg.mqtt_port;
  doc["mqtt_user"] = cfg.mqtt_user;
  doc["mqtt_pass"] = cfg.mqtt_pass;
  doc["blynk_token"] = cfg.blynk_token;
  doc["device_id"] = cfg.device_id;
  doc["mode"] = cfg.mode;
  File f = SD.open("config.json", FILE_WRITE);
  if(!f){ logEvent("failed write config"); return; }
  serializeJson(doc, f);
  f.close();
}

// WebSocket handlers
void onWebSocketEvent(uint8_t num, WStype_t type, uint8_t * payload, size_t length){
  if(type == WStype_TEXT){
    // simple echo or commands
    String msg = String((char*)payload);
    logEvent("WS recv: " + msg);
    if(msg == "serial_clear"){
      logEvent("serial cleared by client");
    }
  }
}

// Simple web pages for provisioning and serial monitor
const char index_html[] PROGMEM = R"rawliteral(
<!doctype html>
<html>
<head><meta charset="utf-8"><title>ESP32 Provision</title></head>
<body>
<h3>ESP32 Provisioning</h3>
<form id="f">
SSID: <input id="ssid"><br>
Pass: <input id="pass"><br>
MQTT: <input id="mqtt"><br>
MQTT Port: <input id="mport"><br>
Blynk token: <input id="blynk"><br>
Device ID: <input id="did"><br>
Mode: <input id="mode"><br>
<button type="button" onclick="save()">Save</button>
</form>
<script>
function save(){
  const body = {ssid:document.getElementById('ssid').value, pass:document.getElementById('pass').value, mqtt_server:document.getElementById('mqtt').value, mqtt_port:parseInt(document.getElementById('mport').value)||1883, blynk_token:document.getElementById('blynk').value, device_id:document.getElementById('did').value, mode:document.getElementById('mode').value};
  fetch('/save', {method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify(body)}).then(r=>r.text()).then(t=>alert(t));
}
</script>
</body>
</html>
)rawliteral";

const char serial_html[] PROGMEM = R"rawliteral(
<!doctype html>
<html>
<head><meta charset="utf-8"><title>Serial Monitor</title></head>
<body>
<h3>Web Serial Monitor</h3>
<pre id="log"></pre>
<script>
var ws = new WebSocket('ws://' + location.hostname + ':81/');
ws.onmessage = function(evt){
  document.getElementById('log').textContent += evt.data + '\n';
};
</script>
</body>
</html>
)rawliteral";

// MQTT Topics
String telemetryTopic;
String commandTopic;

// Publish telemetry to MQTT and Blynk
void publishTelemetry(float lux){
  // build JSON
  DynamicJsonDocument doc(256);
  doc["device_id"] = cfg.device_id;
  doc["lux"] = lux;
  String out;
  serializeJson(doc, out);

  // MQTT plaintext or TLS depending on flags
  mqttClient.publish(telemetryTopic.c_str(), out.c_str());
  logEvent("Published telemetry: " + out);

  #ifdef BLYNK
    if(cfg.blynk_token.length()>0){
      // Blynk virtual write on V1
      Blynk.virtualWrite(V1, lux);
    }
  #endif
}

void mqttCallback(char* topic, byte* payload, unsigned int length){
  String t = String(topic);
  String msg;
  for(unsigned int i=0;i<length;i++) msg += (char)payload[i];
  logEvent("MQTT recv [" + t + "]: " + msg);
  // simple command: LED ON/OFF
  if(t == commandTopic){
    if(msg.indexOf("LED_ON")>=0) digitalWrite(LED_PIN, HIGH);
    if(msg.indexOf("LED_OFF")>=0) digitalWrite(LED_PIN, LOW);
  }
}

void setupWiFiAPMode(){
  WiFi.mode(WIFI_AP);
  String ss = "iot-provision-" + String(ESP.getChipId());
  WiFi.softAP(ss.c_str());
  logEvent("Started AP: " + ss);
}

void setupAPandServer(){
  server.on("/", HTTP_GET, [](AsyncWebServerRequest *request){ request->send_P(200, "text/html", index_html); });
  server.on("/save", HTTP_POST, [](AsyncWebServerRequest *request){
    int len = request->contentLength();
    AsyncWebServerResponse *response = request->beginResponse(200, "text/plain", "OK");
    request->onData([&](uint8_t *data, size_t lenData, size_t index, size_t total){
      String body;
      for(size_t i=0;i<lenData;i++) body += (char)data[i];
      DynamicJsonDocument doc(1024);
      deserializeJson(doc, body);
      cfg.ssid = String((const char*)doc["ssid"]);
      cfg.pass = String((const char*)doc["pass"]);
      cfg.mqtt_server = String((const char*)doc["mqtt_server"]);
      cfg.mqtt_port = doc["mqtt_port"] | 1883;
      cfg.blynk_token = String((const char*)doc["blynk_token"]);
      cfg.device_id = String((const char*)doc["device_id"]);
      cfg.mode = String((const char*)doc["mode"]);
      saveConfig();
      logEvent("Saved config via Web");
    });
    request->send(response);
  });

  server.on("/serial", HTTP_GET, [](AsyncWebServerRequest *request){ request->send_P(200, "text/html", serial_html); });
  server.begin();
  webSocket.begin();
  webSocket.onEvent(onWebSocketEvent);
}

void setup(){
  Serial.begin(115200);
  pinMode(LED_PIN, OUTPUT);
  pinMode(BUZZER_PIN, OUTPUT);
  pinMode(BUTTON_PIN, INPUT_PULLUP);

  if(!SD.begin(SD_CS)){
    logEvent("SD init failed - starting AP for provisioning");
    setupWiFiAPMode();
    setupAPandServer();
    return; // wait for config via web
  }

  if(!loadConfig()){
    logEvent("No valid config - start AP");
    setupWiFiAPMode();
    setupAPandServer();
    return;
  }

  // connect to WiFi (vulnerable options controlled by flags)
  #ifdef WIFI_OPEN
    WiFi.begin(cfg.ssid.c_str()); // no password
  #else
    WiFi.begin(cfg.ssid.c_str(), cfg.pass.c_str());
  #endif

  unsigned long start = millis();
  while(WiFi.status() != WL_CONNECTED && millis() - start < 20000){
    delay(200);
    logEvent("Connecting to WiFi...");
  }
  if(WiFi.status() != WL_CONNECTED){
    logEvent("WiFi failed - starting AP");
    setupWiFiAPMode();
    setupAPandServer();
    return;
  }
  logEvent("WiFi connected: " + WiFi.localIP().toString());

  // Setup webserver and websocket for serial monitor
  setupAPandServer();

  // Setup MQTT
  mqttClient.setServer(cfg.mqtt_server.c_str(), cfg.mqtt_port);
  mqttClient.setCallback(mqttCallback);
  telemetryTopic = String("classroom/") + cfg.device_id + "/telemetry";
  commandTopic = String("classroom/") + cfg.device_id + "/cmd";

  // connect MQTT - vulnerabilities: anonymous or with creds
  #ifdef MQTT_ANON
    if(!mqttClient.connect(cfg.device_id.c_str())){
      logEvent("MQTT connect failed (anon)");
    }
  #else
    if(!mqttClient.connect(cfg.device_id.c_str(), cfg.mqtt_user.c_str(), cfg.mqtt_pass.c_str())){
      logEvent("MQTT connect failed (auth)");
    }
  #endif

  // nRF24 init (radio may be plain or encrypted depending on flags)
  radio.begin();
  radio.setPALevel(RF24_PA_LOW);
  radio.openWritingPipe(0xF0F0F0F0E1LL);
  radio.openReadingPipe(1, 0xF0F0F0F0D2LL);
  radio.startListening();

  logEvent("Setup complete - running main loop");
}

unsigned long lastPub = 0;

void loop(){
  webSocket.loop();
  mqttClient.loop();
  // read LDR
  int raw = analogRead(LDR_PIN);
  float lux = raw; // simple mapping

  if(millis() - lastPub > 5000){
    lastPub = millis();
    publishTelemetry(lux);
  }

  // handle radio receive simple demo
  if(radio.available()){
    char buf[32];
    radio.read(&buf, sizeof(buf));
    logEvent(String("RF recv: ") + String(buf));
    // if payload instructs LED
    if(String(buf).indexOf("LED_ON")>=0) digitalWrite(LED_PIN, HIGH);
    if(String(buf).indexOf("LED_OFF")>=0) digitalWrite(LED_PIN, LOW);
  }

  // button to trigger publish
  if(digitalRead(BUTTON_PIN)==LOW){
    logEvent("Button pressed - manual publish");
    publishTelemetry(analogRead(LDR_PIN));
    delay(500);
  }
}
```

---

=== data/config.json (example) ===
```json
{
  "ssid": "YourSSID",
  "pass": "YourPassword",
  "mqtt_server": "broker.hivemq.com",
  "mqtt_port": 1883,
  "mqtt_user": "",
  "mqtt_pass": "",
  "blynk_token": "",
  "device_id": "node01",
  "mode": "FW1"
}